Perfect â€” now I will generate the **FULL PRODUCER + CONSUMER SYSTEM** designed specifically for your **explicit exponential retry RabbitMQConfig**.

This section gives you:

# â­ What You Will Get

### âœ” Producer (with persistent messages + retry header = 0)

### âœ” Unified Exponential Retry Consumer Template

### âœ” Individual Consumers for:

#### ğŸ”¹ Attendance

#### ğŸ”¹ Email

#### ğŸ”¹ SMS

#### ğŸ”¹ Quiz DB

#### ğŸ”¹ Quiz Redis

#### ğŸ”¹ Quiz Rank

#### ğŸ”¹ Quiz All

#### ğŸ”¹ Broadcast Q1

#### ğŸ”¹ Broadcast Q2

### âœ” Auto Routing for Retry Level â†’ Retry Queue

### âœ” Final DLQ Handling

### âœ” 100% compatible with your massive explicit RabbitMQConfig

---

# ğŸ“Œ CONSTANTS USED FOR RETRY

Retry schedule MUST match your config:

| Retry    | TTL        | Retry Routing Key |
| -------- | ---------- | ----------------- |
| Retry #1 | 5 seconds  | `{queue}.retry.1` |
| Retry #2 | 15 seconds | `{queue}.retry.2` |
| Retry #3 | 45 seconds | `{queue}.retry.3` |
| Final    | â€”          | `{queue}.final`   |

---

# ğŸŸ© PART 1 â€” **PRODUCER (unified for all events)**

### File: `EventProducer.java`

```java
package com.icsquiz.producer;

import com.icsquiz.dto.*;
import org.springframework.amqp.core.MessageDeliveryMode;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.stereotype.Service;

@Service
public class EventProducer {

    private final RabbitTemplate rabbit;

    public EventProducer(RabbitTemplate rabbitTemplate) {
        this.rabbit = rabbitTemplate;
    }

    private <T> void send(String exchange, String routingKey, T event) {
        rabbit.convertAndSend(exchange, routingKey, event, msg -> {
            msg.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
            msg.getMessageProperties().setHeader("x-retry-count", 0);
            return msg;
        });

        System.out.println("â¡ Sent to " + exchange + " [" + routingKey + "] â†’ " + event);
    }

    /* ===========================
       DIRECT: LOGIN EVENTS
       =========================== */

    public void sendAttendance(LoginEvent event) {
        send("login_direct_exchange", "login.attendance", event);
    }

    public void sendEmail(LoginEvent event) {
        send("login_direct_exchange", "login.email", event);
    }

    public void sendSms(LoginEvent event) {
        send("login_direct_exchange", "login.sms", event);
    }

    /* ===========================
       TOPIC: QUIZ EVENTS
       =========================== */

    public void sendQuizDb(QuizSubmissionEvent event) {
        send("quiz_topic_exchange", "quiz.submission.db", event);
    }

    public void sendQuizRedis(QuizSubmissionEvent event) {
        send("quiz_topic_exchange", "quiz.submission.redis", event);
    }

    public void sendQuizRank(QuizSubmissionEvent event) {
        send("quiz_topic_exchange", "quiz.submission.rank", event);
    }

    public void sendQuizAll(QuizSubmissionEvent event, String dynamicRoutingKey) {
        send("quiz_topic_exchange", dynamicRoutingKey, event);
    }

    /* ===========================
       FANOUT: BROADCAST EVENTS
       =========================== */

    public void sendBroadcast(BroadcastEvent event) {
        send("broadcast_fanout_exchange", "", event);
    }
}
```

---

# ğŸŸ© PART 2 â€” **UNIFIED RETRY HANDLER (core logic)**

### File: `RetryHandler.java`

```java
package com.icsquiz.util;

import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.stereotype.Component;

@Component
public class RetryHandler {

    private final RabbitTemplate rabbit;
    private static final int MAX_RETRIES = 3;

    public RetryHandler(RabbitTemplate rabbit) {
        this.rabbit = rabbit;
    }

    public boolean handleRetry(
            Message msg,
            Object event,
            String exchange,
            String queueBase
    ) {
        int retryCount = msg.getMessageProperties().getHeader("x-retry-count") == null
                ? 0
                : (int) msg.getMessageProperties().getHeader("x-retry-count");

        System.out.println("âŸ³ RetryHandler for [" + queueBase + "] â†’ retry = " + retryCount);

        if (retryCount >= MAX_RETRIES) {
            System.out.println("âŒ Max retries reached â†’ FINAL DLQ");
            rabbit.convertAndSend(exchange, queueBase + ".final", event);
            return false; // STOP processing
        }

        retryCount++;

        String retryRoutingKey = switch (retryCount) {
            case 1 -> queueBase + ".retry.1";
            case 2 -> queueBase + ".retry.2";
            case 3 -> queueBase + ".retry.3";
            default -> queueBase + ".final";
        };

        System.out.println("â³ Sending to Retry Level " + retryCount + " â†’ " + retryRoutingKey);

        rabbit.convertAndSend(exchange, retryRoutingKey, event, m -> {
            m.getMessageProperties().setHeader("x-retry-count", retryCount);
            return m;
        });

        return true; // RETRY triggered, stop further consumer logic
    }
}
```

---

# ğŸŸ© PART 3 â€” **CONSUMERS FOR EACH QUEUE**

All consumers follow the same structure:

### âœ” Try

### âœ” Catch â†’ RetryHandler decides retry/final

### âœ” If retry requested â†’ consumer returns

### âœ” If success â†’ process normally

---

# ğŸŸ¦ 3.1 â€” Attendance Consumer

```java
package com.icsquiz.consumer;

import com.icsquiz.dto.LoginEvent;
import com.icsquiz.util.RetryHandler;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Service;

@Service
public class AttendanceConsumer {

    private final RetryHandler retry;

    public AttendanceConsumer(RetryHandler retry) { this.retry = retry; }

    @RabbitListener(queues = "attendance_queue")
    public void handle(Message msg, LoginEvent event) {

        try {
            System.out.println("âœ” Attendance handled: " + event);
            throw new RuntimeException("Simulated Attendance Error");

        } catch (Exception e) {
            if (retry.handleRetry(msg, event, "login_direct_exchange", "attendance_queue"))
                return;
        }
    }
}
```

---

# ğŸŸ¦ 3.2 â€” Email Consumer

```java
@Service
public class EmailConsumer {

    private final RetryHandler retry;

    public EmailConsumer(RetryHandler retry) { this.retry = retry; }

    @RabbitListener(queues = "email_queue")
    public void handle(Message msg, LoginEvent event) {

        try {
            System.out.println("âœ” Email sent: " + event);
            throw new RuntimeException("Email API Down");

        } catch (Exception e) {
            if (retry.handleRetry(msg, event, "login_direct_exchange", "email_queue"))
                return;
        }
    }
}
```

---

# ğŸŸ¦ 3.3 â€” SMS Consumer

```java
@Service
public class SmsConsumer {

    private final RetryHandler retry;

    public SmsConsumer(RetryHandler retry) { this.retry = retry; }

    @RabbitListener(queues = "sms_queue")
    public void handle(Message msg, LoginEvent event) {

        try {
            System.out.println("âœ” SMS sent: " + event);
            throw new RuntimeException("SMS Gateway Failure");

        } catch (Exception e) {
            if (retry.handleRetry(msg, event, "login_direct_exchange", "sms_queue"))
                return;
        }
    }
}
```

---

# ğŸŸ¦ 3.4 â€” Quiz DB Consumer

```java
@Service
public class QuizDbConsumer {

    private final RetryHandler retry;

    public QuizDbConsumer(RetryHandler retry) { this.retry = retry; }

    @RabbitListener(queues = "quiz_db_queue")
    public void handle(Message msg, QuizSubmissionEvent event) {

        try {
            System.out.println("âœ” Saving Quiz Score to DB: " + event);
            throw new RuntimeException("DB Insert Failed");

        } catch (Exception e) {
            if (retry.handleRetry(msg, event, "quiz_topic_exchange", "quiz_db_queue"))
                return;
        }
    }
}
```

---

# ğŸŸ¦ 3.5 â€” Quiz Redis Consumer

```java
@Service
public class QuizRedisConsumer {

    private final RetryHandler retry;

    public QuizRedisConsumer(RetryHandler retry) { this.retry = retry; }

    @RabbitListener(queues = "quiz_redis_queue")
    public void handle(Message msg, QuizSubmissionEvent event) {

        try {
            System.out.println("âœ” Redis Live Update: " + event);
            throw new RuntimeException("Redis Error");

        } catch (Exception e) {
            if (retry.handleRetry(msg, event, "quiz_topic_exchange", "quiz_redis_queue"))
                return;
        }
    }
}
```

---

# ğŸŸ¦ 3.6 â€” Quiz Rank Consumer

```java
@Service
public class QuizRankConsumer {

    private final RetryHandler retry;

    public QuizRankConsumer(RetryHandler retry) { this.retry = retry; }

    @RabbitListener(queues = "quiz_rank_queue")
    public void handle(Message msg, QuizSubmissionEvent event) {

        try {
            System.out.println("âœ” Updating Rank Table: " + event);
            throw new RuntimeException("Rank Update Failure");

        } catch (Exception e) {
            if (retry.handleRetry(msg, event, "quiz_topic_exchange", "quiz_rank_queue"))
                return;
        }
    }
}
```

---

# ğŸŸ¦ 3.7 â€” Quiz All Consumer (pattern listener)

```java
@Service
public class QuizAllConsumer {

    private final RetryHandler retry;

    public QuizAllConsumer(RetryHandler retry) { this.retry = retry; }

    @RabbitListener(queues = "quiz_all_queue")
    public void handle(Message msg, QuizSubmissionEvent event) {

        try {
            System.out.println("âœ” Global Quiz Listener (quiz.#): " + event);
            // no retry needed unless fail
        } catch (Exception e) {
            if (retry.handleRetry(msg, event, "quiz_topic_exchange", "quiz_all_queue"))
                return;
        }
    }
}
```

---

# ğŸŸ¦ 3.8 â€” Broadcast Consumers

### Broadcast Q1:

```java
@Service
public class BroadcastQ1Consumer {

    private final RetryHandler retry;

    public BroadcastQ1Consumer(RetryHandler retry) { this.retry = retry; }

    @RabbitListener(queues = "broadcast_q1")
    public void handle(Message msg, BroadcastEvent event) {

        try {
            System.out.println("âœ” Broadcast Q1: " + event);
            throw new RuntimeException("Notification Module Down");

        } catch (Exception e) {
            if (retry.handleRetry(msg, event, "broadcast_fanout_exchange", "broadcast_q1"))
                return;
        }
    }
}
```

### Broadcast Q2:

```java
@Service
public class BroadcastQ2Consumer {

    private final RetryHandler retry;

    public BroadcastQ2Consumer(RetryHandler retry) { this.retry = retry; }

    @RabbitListener(queues = "broadcast_q2")
    public void handle(Message msg, BroadcastEvent event) {

        try {
            System.out.println("âœ” Broadcast Q2: " + event);

        } catch (Exception e) {
            if (retry.handleRetry(msg, event, "broadcast_fanout_exchange", "broadcast_q2"))
                return;
        }
    }
}
```

---

# â­ FINAL SYSTEM BEHAVIOR

### On Failure:

```
Main queue â†’ retry_1 (5 sec)
retry_1 â†’ retry_2 (15 sec)
retry_2 â†’ retry_3 (45 sec)
retry_3 â†’ FINAL DLQ
```

### On Success:

```
Consumer completes â†’ no retry
```

---

# â­ Want Next?

I can also generate:

### âœ” Retry Monitoring Dashboard API

### âœ” Automatic Email Alert when messages reach FINAL DLQ

### âœ” Exponential Backoff Diagram

### âœ” Microservice separation with RabbitMQ routing maps

### âœ” Load-testing script (k6) for this RabbitMQ system

Just say:

ğŸ‘‰ **â€œGenerate retry dashboardâ€**
or
ğŸ‘‰ **â€œGive diagramâ€**
