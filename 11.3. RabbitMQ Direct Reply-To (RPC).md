‡¶®‡¶ø‡¶ö‡ßá ‡¶Ü‡¶Æ‡¶ø ‡¶§‡ßã‡¶Æ‡¶æ‡¶ï‡ßá **RabbitMQ Direct Reply-To (RPC)** ‡¶è‡¶∞ **‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£, 100% working Spring Boot Java Code** ‡¶¶‡¶ø‡¶ö‡ßç‡¶õ‡¶ø‡•§

‡¶è‡¶ü‡¶ø real-life microservice style:

* ‚úî Producer ‚Üí Request ‡¶™‡¶æ‡¶†‡¶æ‡ßü
* ‚úî Consumer ‚Üí Response ‡¶™‡¶æ‡¶†‡¶æ‡ßü
* ‚úî Producer Direct Reply-To ‡¶¶‡¶ø‡ßü‡ßá instant ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶™‡¶æ‡ßü
* ‚úî ‡¶ï‡ßã‡¶®‡ßã reply queue declare ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡ßü ‡¶®‡¶æ
* ‚úî RabbitMQ ‡¶è‡¶∞ special queue: `amq.rabbitmq.reply-to` auto ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶π‡ßü

‡¶è‡¶á ‡¶ï‡ßã‡¶° ‡¶ï‡¶™‡¶ø-‡¶™‡ßá‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶≤‡ßá‡¶á ‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ Spring Boot ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™ RPC-style request‚Äìresponse ‡¶ö‡¶æ‡¶≤‡¶æ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡•§

---

# üü¶ 1Ô∏è‚É£ **RabbitMQ Config (No reply queue needed)**

```java
package com.example.rpcdemo.config;

import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitConfig {

    @Bean
    public CachingConnectionFactory connectionFactory() {
        CachingConnectionFactory factory = new CachingConnectionFactory("localhost");
        factory.setUsername("guest");
        factory.setPassword("guest");

        // enable publisher confirms (optional but good)
        factory.setPublisherReturns(true);
        factory.setPublisherConfirmType(CachingConnectionFactory.ConfirmType.CORRELATED);

        return factory;
    }

    @Bean
    public RabbitTemplate rabbitTemplate(CachingConnectionFactory factory) {
        RabbitTemplate template = new RabbitTemplate(factory);

        // Direct Reply-To enabled by default in Spring
        template.setUseDirectReplyToContainer(true);

        return template;
    }
}
```

---

# üü¶ 2Ô∏è‚É£ **Consumer (Service responding to requests)**

Consumer queue: `"rpc.request.queue"`

```java
package com.example.rpcdemo.consumer;

import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Service;

@Service
public class RpcRequestConsumer {

    @RabbitListener(queues = "rpc.request.queue")
    public String handleRpcRequest(String message) {
        System.out.println("üì• Received RPC Request: " + message);

        // Process request
        String response = "Processed: " + message;

        System.out.println("üì§ Sending RPC Response: " + response);

        return response; // this automatically goes to Direct Reply-To
    }
}
```

‚úî Consumer ‡¶∂‡ßÅ‡¶ß‡ßÅ return ‡¶ï‡¶∞‡¶≤‡ßá‡¶á Spring RabbitMQ reply ‡¶™‡¶æ‡¶†‡¶ø‡ßü‡ßá ‡¶¶‡ßá‡¶¨‡ßá Producer-‡¶è‡¶∞ `amq.rabbitmq.reply-to` queue-‡¶§‡ßá‡•§

---

# üü¶ 3Ô∏è‚É£ **Queue Declaration**

```java
package com.example.rpcdemo.config;

import org.springframework.amqp.core.Queue;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class QueueConfig {

    @Bean
    public Queue rpcQueue() {
        return new Queue("rpc.request.queue", true);
    }
}
```

---

# üü¶ 4Ô∏è‚É£ **Producer (Direct Reply-To RPC Caller)**

Producer ‡¶è‡¶ï‡¶ü‡¶ø request ‡¶™‡¶æ‡¶†‡¶æ‡ßü ‡¶è‡¶¨‡¶Ç synchronous reply ‡¶™‡¶æ‡ßü‡•§

```java
package com.example.rpcdemo.producer;

import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.stereotype.Service;

@Service
public class RpcClientProducer {

    private final RabbitTemplate rabbitTemplate;

    public RpcClientProducer(RabbitTemplate rabbitTemplate) {
        this.rabbitTemplate = rabbitTemplate;
    }

    public Object sendRpcRequest(String message) {
        System.out.println("‚û°Ô∏è Sending RPC Request: " + message);

        Object response = rabbitTemplate.convertSendAndReceive(
                "",
                "rpc.request.queue",
                message
        );

        System.out.println("‚¨ÖÔ∏è RPC Response Received: " + response);

        return response;
    }
}
```

**‡¶ñ‡ßá‡ßü‡¶æ‡¶≤ ‡¶ï‡¶∞‡ßã:**
`convertSendAndReceive()` ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶≤‡ßá Spring Boot automatically Direct Reply-To ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡•§

---

# üü¶ 5Ô∏è‚É£ **Controller for Testing**

```java
package com.example.rpcdemo.controller;

import com.example.rpcdemo.producer.RpcClientProducer;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class RpcTestController {

    private final RpcClientProducer rpcClient;

    public RpcTestController(RpcClientProducer rpcClient) {
        this.rpcClient = rpcClient;
    }

    @GetMapping("/test-rpc")
    public String testRpc() {
        Object response = rpcClient.sendRpcRequest("Hello From Client!");
        return "RPC Response: " + response;
    }
}
```

---

# üü¶ 6Ô∏è‚É£ **Application Flow**

1. Browser hit:

```
GET http://localhost:8080/test-rpc
```

2. Producer sends:

```
RPC Request ‚Üí rpc.request.queue
```

3. Consumer receives request + returns response:

```
return "Processed: Hello From Client"
```

4. RabbitMQ sends reply ‚Üí Direct Reply-To queue:

```
amq.rabbitmq.reply-to
```

5. Producer instantly receives response:

```
RPC Response Received: Processed: Hello From Client
```

---

# üü© **Complete Flow Diagram**

```
Client ‚Üí Producer ‚Üí rpc.request.queue ‚Üí Consumer
Consumer ‚Üí reply-to: amq.rabbitmq.reply-to ‚Üí Producer
Producer ‚Üí returns response to Client
```

---

# üü© ‡¶è‡¶ï ‡¶≤‡¶æ‡¶á‡¶®‡ßá Summary

üëâ **‡¶è‡¶á ‡¶ï‡ßã‡¶°‡ßá ‡¶§‡ßÅ‡¶Æ‡¶ø full RPC system ‡¶™‡ßá‡ßü‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá Producer ‡¶®‡¶ø‡¶ú‡ßá‡¶∞ reply queue manage ‡¶®‡¶æ ‡¶ï‡¶∞‡ßá‡¶ì Direct Reply-To ‡¶¶‡¶ø‡ßü‡ßá instant response ‡¶™‡¶æ‡ßü‡•§**

---

‡¶Ø‡¶¶‡¶ø ‡¶ö‡¶æ‡¶ì, ‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶∞‡ßá‡¶ï‡¶ü‡¶æ ‡¶¶‡¶ø‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø‚Äî

‚úî Asynchronous RPC (callback handled)
‚úî RPC with timeout + retry + backoff
‚úî Microservice-based RPC architecture diagram
‚úî Load balancing RPC consumer pool

Which one do you want?
