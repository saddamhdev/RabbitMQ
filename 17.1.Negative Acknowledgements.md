**Negative Acknowledgements (NACK)** рж╣рж▓рзЛ RabbitMQ-ржПрж░ ржПржХржЯрж┐ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг feature, ржпрж╛ ржмрж▓рзЗ ржжрзЗрзЯ:

ЁЯСЙ Consumer message **process ржХрж░рждрзЗ ржмрзНржпрж░рзНрже рж╣рзЯрзЗржЫрзЗ**
ЁЯСЙ Message **requeue** ржХрж░рж╛ рж╣ржмрзЗ ржирж╛ржХрж┐ **DLQ** (Dead Letter Queue)-ржП ржпрж╛ржмрзЗ
ЁЯСЙ Consumer failure handling automated ржХрж░рж╛ ржпрж╛рзЯ

ржЪрж▓ ржПржХржжржо рж╕рж╣ржЬ ржнрж╛рж╖рж╛рзЯ ржмрзБржЭрж┐ред

---

# ЁЯЯе **What Is Negative Acknowledgement (NACK)?**

ржпржЦржи consumer ржХрзЛржирзЛ message **process ржХрж░рждрзЗ ржкрж╛рж░рзЗ ржирж╛** (error, exception, failure):

Consumer RabbitMQ-ржХрзЗ ржЬрж╛ржирж╛рзЯ:

```
NACK = ржЖржорж┐ message handle ржХрж░рждрзЗ ржкрж╛рж░рж▓рж╛ржо ржирж╛ред
```

RabbitMQ ржПрж░ржкрж░ рж╕рж┐ржжрзНржзрж╛ржирзНржд ржирзЗрзЯ:

```
Requeue тЖТ ржЖржмрж╛рж░ consume рж╣ржмрзЗ
OR
Reject тЖТ DLQ-рждрзЗ ржпрж╛ржмрзЗ (if DLX configured)
```

---

# ЁЯЯж **ACK vs NACK vs Reject**

| Type                     | Meaning                          | Message fate                |
| ------------------------ | -------------------------------- | --------------------------- |
| **ACK**                  | Success                          | Remove from queue           |
| **NACK + requeue=true**  | Fail but try again               | Queue-рждрзЗ ржлрж┐рж░рзЗ ржпрж╛ржмрзЗ          |
| **NACK + requeue=false** | Fail permanently                 | DLQ-рждрзЗ ржпрж╛ржмрзЗ (if DLX exists) |
| **Reject**               | Similar to NACK but cannot batch | Requeue or DLQ              |

---

# ЁЯЯз Flow Diagram

```
Consumer тЖТ error тЖТ NACK тЖТ (requeue or DLQ)
```

![Image](https://www.cloudamqp.com/img/blog/exchanges-topic-fanout-direct.png?utm_source=chatgpt.com)

![Image](https://www.cloudamqp.com/img/blog/dead-letter-exchange.png?utm_source=chatgpt.com)

---

# ЁЯЯж Why NACK Is Important?

тЬФ Prevents silent data loss
тЬФ Allows retry logic
тЬФ Protects queue from stuck messages
тЬФ Enables DLX-based error routing
тЬФ Makes microservices fault-tolerant

---

# ЁЯЯй Types of Negative Acknowledgement

## 1я╕ПтГг **nack(message, requeue = true)**

Message ржЖржмрж╛рж░ queue-рждрзЗ ржлрж┐рж░рзЗ ржпрж╛ржмрзЗред

Useful ржпржЦржи:

* Temporary DB down
* External API error
* Service overloaded

---

## 2я╕ПтГг **nack(message, requeue = false)**

Message DLQ-рждрзЗ ржпрж╛ржмрзЗ (if configured).

Useful ржпржЦржи:

* Invalid data
* Corrupted payload
* Permanent business error
* Fraud / malicious data

---

# ЁЯЯж Java / Spring Boot Example

## тЬФ Scenario: Consumer fails during processing

```java
@RabbitListener(queues = "task.queue")
public void handleMessage(Message message, Channel channel) throws Exception {

    try {
        String body = new String(message.getBody());
        System.out.println("Received: " + body);

        // simulate error
        if (body.contains("fail")) {
            throw new RuntimeException("Processing failed!");
        }

        // Success тЖТ ACK
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);

    } catch (Exception e) {

        System.out.println("NACK Sent (DLQ or Requeue)");

        // Send Negative Acknowledgment
        channel.basicNack(
                message.getMessageProperties().getDeliveryTag(),
                false,     // multiple messages?
                false      // requeue? false = send to DLQ
        );
    }
}
```

тЬФ `basicNack()` used
тЬФ requeue=false тЖТ DLQ-рждрзЗ ржпрж╛ржмрзЗ
тЬФ ржпржжрж┐ DLX ржирж╛ ржерж╛ржХрзЗ тЖТ message discard рж╣ржмрзЗ

---

# ЁЯЯе Spring Boot Default Behavior (IMPORTANT)

Spring Boot `RabbitListener` ржбрж┐ржлрж▓рзНржЯржнрж╛ржмрзЗ:

* Exception рж╣рж▓рзЗ
* **Message auto-requeue рж╣ржмрзЗ**

This may cause **infinite retry loop**! тЪая╕П

рждрж╛ржЗ production ржП рж╕ржмрж╕ржорзЯ configure ржХрж░рждрзЗ рж╣рзЯ:

```java
factory.setDefaultRequeueRejected(false);
```

ржПрждрзЗ message DLQ-рждрзЗ ржпрж╛ржмрзЗ, requeue рж╣ржмрзЗ ржирж╛ред

---

# ЁЯЯж How NACK Works With DLQ (Dead Letter Queue)

```
NACK requeue=false
       тЖУ
DLX (dead letter exchange)
       тЖУ
DLQ (dead letter queue)
```

---

# ЁЯЯй Real Microservice Scenario

### Example: Payment validation

If request data invalid:

```
nack(requeue=false) тЖТ DLQ тЖТ store + alert тЖТ human review
```

### Example: API temporarily down

```
nack(requeue=true) тЖТ message retried later
```

---

# ЁЯЯж Best Practices

тЬФ Use `nack(requeue=false)` for permanent business errors
тЬФ Use `nack(requeue=true)` for temporary errors
тЬФ Always configure DLX for safe error handling
тЬФ Avoid infinite requeue loops
тЬФ Use retry + exponential backoff

---

# тнР One-Line Summary

ЁЯСЙ **Negative Acknowledgement (NACK)** RabbitMQ-ржХрзЗ ржЬрж╛ржирж╛рзЯ ржпрзЗ message process рж╣рзЯржирж┐ тАФ ржПрж░ржкрж░ RabbitMQ message-ржХрзЗ **requeue ржХрж░ржмрзЗ** ржмрж╛ **DLQ-рждрзЗ ржкрж╛ржарж╛ржмрзЗ**ред

---

# ржпржжрж┐ ржЪрж╛ржУ ЁЯФе

ржЖржорж┐ ржжрж┐рждрзЗ ржкрж╛рж░рж┐:

тЬФ NACK + DLQ + Retry + Backoff full architecture
тЬФ Spring Boot full example with manual ACK/NACK
тЬФ NACK-based fault-tolerant microservice design diagram
тЬФ Production-ready Messaging Error Strategy

Which one do you want next?
